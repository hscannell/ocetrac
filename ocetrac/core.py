# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['track']

# Cell
from nbdev.showdoc import *
import xarray as xr
import numpy as np
import scipy.ndimage
from skimage.measure import regionprops
from skimage.measure import label as label_np
import dask.array as dsa

# import matplotlib.pyplot as plt


# Cell
def _morphological_operations(da, radius=8):
    '''Converts xarray.DataArray to binary, defines structuring element, and performs morphological closing then opening.
    Parameters
    ----------
    da     : xarray.DataArray
            The data to label
    radius : int
            Length of grid spacing to define the radius of the structing element used in morphological closing and opening.

    '''

    # Convert images to binary. All positive values == 1, otherwise == 0
    bitmap_binary = da.where(da>0, drop=False, other=0)
    bitmap_binary = bitmap_binary.where(bitmap_binary==0, drop=False, other=1)

    # Define structuring element
    diameter = radius*2
    x = np.arange(-radius, radius+1)
    x, y = np.meshgrid(x, x)
    r = x**2+y**2
    se = r<radius**2

    def binary_open_close(bitmap_binary):
        bitmap_binary_padded = np.pad(bitmap_binary,
                                      ((diameter, diameter), (diameter, diameter)),
                                      mode='wrap')
        s1 = scipy.ndimage.binary_closing(bitmap_binary_padded, se, iterations=1)
        s2 = scipy.ndimage.binary_opening(s1, se, iterations=1)
        unpadded= s2[diameter:-diameter, diameter:-diameter]
        return unpadded

    mo_binary = xr.apply_ufunc(binary_open_close, bitmap_binary,
                               input_core_dims=[['lat', 'lon']],
                               output_core_dims=[['lat', 'lon']],
                               output_dtypes=[bitmap_binary.dtype],
                               vectorize=True,
                               dask='parallelized')

    return mo_binary


# Cell
def _id(binary_images):
    '''label object from binary images, without trackin in time. '''

    unique_labels, num = xr.apply_ufunc(
        label_np,
        binary_images,
        kwargs={'return_num': True, 'connectivity': 2},
        input_core_dims=[['lat', 'lon', ]],
        output_core_dims=[['lat', 'lon'], []],
        output_dtypes=['i4', 'i4'],
        dask='parallelized',
        vectorize=True
    )

    #non_core_dims = set(binary_images.dims) - {'lat', 'lon'}
    # TODO: stop assuming 3D images

    offset = num.cumsum().shift(time=1, fill_value=0)
    unique_labels = xr.where(unique_labels > 0, unique_labels + offset, 0)

    return unique_labels

# Cell
def _filter_area(mo_binary, min_size_quartile):
    '''calculatre area with regionprops'''

    unique_labels = _id(mo_binary)
    props = regionprops(unique_labels.values.astype('int'))

    labelprops = [p.label for p in props]
    labelprops = xr.DataArray(labelprops, dims=['label'], coords={'label': labelprops})
    coords = [p.coords for p in props] # time, lat, lon
    area = xr.DataArray([p.area for p in props], dims=['label'], coords={'label': labelprops})  # Number of pixels of the region.
    min_area = np.percentile(area, min_size_quartile*100)

#     area = []
#     res = mo_binary.lat[1].values-mo_binary.lat[0].values # resolution of latitude
#     for i in range(len(coords)):
#         area.append(np.sum((res*111)*np.cos(np.radians(mo_binary.lat[coords[i][:,0]].values)) * (res*111)))
#     area = xr.DataArray(area, dims=['label'], coords={'label': labelprops})
#     min_area = np.percentile(area, min_size_quartile*100)
    print('min area (km2) \t', min_area)

    keep_labels = labelprops.where(area>=min_area, drop=True)
    ID_area = xr.DataArray(np.isin(unique_labels, keep_labels).reshape(unique_labels.shape),
                               dims=unique_labels.dims, coords=unique_labels.coords)

    return area, min_area, ID_area, labelprops

# Cell
def _label_either(data, **kwargs):
    if isinstance(data, dsa.Array):
        try:
            from dask_image.ndmeasure import label as label_dask
            def label_func(a, **kwargs):
                ids, num = label_dask(a, **kwargs)
                return ids
        except ImportError:
            raise ImportError(
                "Dask_image is required to use this function on Dask arrays. "
                "Either install dask_image or else call .load() on your data."
            )
    else:
        label_func = label_np
    return label_func(data, **kwargs)


# Cell
def _wrap(labels):
    ''' Impose periodic boundary and wrap labels'''
    first_column = labels[..., 0]
    last_column = labels[..., -1]

    unique_first = np.unique(first_column[first_column>0])

    # This loop iterates over the unique values in the first column, finds the location of those values in
    # the first columnm and then uses that index to replace the values in the last column with the first column value
    for i in enumerate(unique_first):
        new_ID = np.where(first_column == i[1])
        bad_labels = np.unique(last_column[new_ID[0], new_ID[1]])
        labels = np.where(labels == bad_labels, i[1], labels)

    new_labels = np.unique(labels, return_inverse=True)[1].reshape(labels.shape)

    # recalculate the total number of labels
    N = np.max(new_labels)

    return new_labels, N


# Cell
def track(da, mask, radius=8, area_quantile=0.75):
    '''Image labeling and tracking.

    Parameters
    ----------
    da : xarray.DataArray
        The data to label.

    radius : int
        size of the structuring element used in morphological opening and closing.

    area_quantile : float
        quantile used to define the threshold of the smallest area object retained in tracking.

    mask : xarray.DataArray
        The mask of ponts to ignore. Must be binary.

    Returns
    -------
    labels : xarray.DataArray
        Integer labels of the connected regions.
    '''

    # Converts data to binary, defines structuring element, and performs morphological closing then opening
    binary_images = _morphological_operations(da, radius=radius)

    area, min_area, ID_area, labelprops = _filter_area(binary_images, area_quantile)

#     if mask.any():
#         try:
#             ID_area = ID_area.where(mask==1, drop=False, other=0)
#             labels, num = _label_either(ID_area, return_num= True, connectivity=3)
#         except ImportError:
#             raise ImportError(
#                 "Mask not used.  "
#                 "Check that dimensions equal da and that it contains a binary set."
#             )
#     else:
#         labels, num = _label_either(ID_area, return_num= True, connectivity=3)

    # Apply mask
#     ID_area = ID_area.where(mask==1, drop=False, other=0)

    labels, num = _label_either(ID_area, return_num= True, connectivity=3)

    new_labels, N = _wrap(labels)
    new_labels = xr.DataArray(new_labels, coords=da.coords)


    # Calculate Percent of total MHW area retained
    tot_area = int(np.sum(area.values))
    small_area = area.where(area<=min_area, drop=True)
    small_area = int(np.sum(small_area.values))
    percent_area_kept = 1-(small_area/tot_area)

    new_labels = new_labels.rename('labels')
    new_labels.attrs['min_area'] = min_area
    new_labels.attrs['percent_area_kept'] = percent_area_kept
    print('inital features identified \t', int(new_labels.max().values))


    print('final features tracked \t', int(N))

    return new_labels, N