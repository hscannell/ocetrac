# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['track']

# Cell
from nbdev.showdoc import *
import xarray as xr
import numpy as np
import scipy.ndimage
from skimage.measure import label, regionprops
# import matplotlib.pyplot as plt


# Cell
def _morphological_operations(da, radius=8):
    '''Converts xarray.DataArray to binary, defines structuring element, and performs morphological closing then opening.
    Parameters
    ----------
    da     : xarray.DataArray
            The data to label
    radius : int
            Length of grid spacing to define the radius of the structing element used in morphological closing and opening.

    '''

    # Convert images to binary. All positive values == 1, otherwise == 0
    bitmap_binary = da.where(da>0, drop=False, other=0)
    bitmap_binary = bitmap_binary.where(bitmap_binary==0, drop=False, other=1)

    # Define structuring element
    diameter = radius*2
    x = np.arange(-radius, radius+1)
    x, y = np.meshgrid(x, x)
    r = x**2+y**2
    se = r<radius**2

    def binary_open_close(bitmap_binary):
        bitmap_binary_padded = np.pad(bitmap_binary,
                                      ((diameter, diameter), (diameter, diameter)),
                                      mode='wrap')
        s1 = scipy.ndimage.binary_closing(bitmap_binary_padded, se, iterations=1)
        s2 = scipy.ndimage.binary_opening(s1, se, iterations=1)
        unpadded= s2[diameter:-diameter, diameter:-diameter]
        return unpadded

    mo_binary = xr.apply_ufunc(binary_open_close, bitmap_binary,
                               input_core_dims=[['lat', 'lon']],
                               output_core_dims=[['lat', 'lon']],
                               output_dtypes=[bitmap_binary.dtype],
                               vectorize=True,
                               dask='parallelized')

    return mo_binary


# Cell
def _id(binary_images):
    '''label object from binary images, without trackin in time. '''

    unique_labels, num = xr.apply_ufunc(
        label,
        binary_images,
        kwargs={'return_num': True, 'connectivity': 2},
        input_core_dims=[['lat', 'lon', ]],
        output_core_dims=[['lat', 'lon'], []],
        output_dtypes=['i4', 'i4'],
        dask='parallelized',
        vectorize=True
    )

    #non_core_dims = set(binary_images.dims) - {'lat', 'lon'}
    # TODO: stop assuming 3D images

    offset = num.cumsum().shift(time=1, fill_value=0)
    unique_labels = xr.where(unique_labels > 0, unique_labels + offset, 0)

    return unique_labels

# Cell
from skimage.measure import label as label_np

def _label_either(data, **kwargs):
    if isinstance(data, dsa.Array):
        try:
            from dask_image.ndmeasure import label as label_dask
            def label_func(a, **kwargs):
                ids, num = label_dask(a, **kwargs)
                return ids
        except ImportError:
            raise ImportError(
                "Dask_image is required to use this function on Dask arrays. "
                "Either install dask_image or else call .load() on your data."
            )
    else:
        label_func = label_np
    return label_func(data, **kwargs)


# Cell
def track(da, radius=8, area_quantile=0.75):
    '''Image labeling and tracking.

    Parameters
    ----------
    da : xarray.DataArray
        The data to label.

    radius : int
        size of the structuring element used in morphological opening and closing.

    area_quantile : float
        quantile used to define the threshold of the smallest area object retained in tracking.

    Returns
    -------
    labels : xarray.DataArray
        Integer labels of the connected regions.
    '''

    # Converts data to binary, defines structuring element, and performs morphological closing then opening
    binary_images = _morphological_operations(da, radius=radius)

    area, min_area, ID_area, labelprops = _filter_area(mo_binary, 0)

    labels, num = _label_either(ID_area, return_num= True, connectivity=3)

    new_labels, N = _wrap(labels)


    ### ! Reapply land maks HERE

    # Calculate Percent of total MHW area retained
    tot_area = int(np.sum(area.values))
    small_area = area.where(area<=min_area, drop=True)
    small_area = int(np.sum(small_area.values))
    percent_area_kept = 1-(small_area/tot_area)

    features = _id(ID_area)
    features = features.rename('labels')
    features.attrs['min_area'] = min_area
    features.attrs['percent_area_kept'] = percent_area_kept
    print('inital features identified \t', int(features.max().values))


    print('final features tracked \t', int(N))

    return new_labels, N